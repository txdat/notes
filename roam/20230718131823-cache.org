:PROPERTIES:
:ID:       f12f8b17-0d81-4950-a475-ec8c572ec770
:END:
#+title: cache

* lru
#+begin_src C++
struct Node {
  int key, value;
  list<int>::const_iterator it;

  // TODO: copy constructor?
  Node() = default;
  explicit Node(int key, int value, list<int>::const_iterator it) : key(key), value(value), it(it) {}
};

struct LRU {
  int capacity;
  unordered_map<int,Node> m;
  list<int> q;

  LRU(int capacity) : capacity(capacity) {}

  // TODO: copy constructor if Node doesn't have explicit constructor
  Node& __touch(Node& p) {
    // update position
    q.erase(p.it);
    q.push_front(p.key);
    p.it = q.cbegin(); // const iterator
    return p;
  }

  int get(int key) {
    return m.find(key) == m.end() ? -1 : __touch(m[key]).value;
  }

  void put(int key, int value) {
    if (m.find(key) != m.end()) {
      __touch(m[key]).value = value;
      return;
    }

    if (q.size() == capacity) {
      // remove least recently element
      m.erase(q.back());
      q.pop_back();
    }

    // add new node
    q.push_front(key);
    m[key] = Node(key, value, q.cbegin());
  }
};
#+end_src

* lfu

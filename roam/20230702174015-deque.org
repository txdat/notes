:PROPERTIES:
:ID:       0f42f7e3-222e-4a53-a981-e53aee300f68
:END:
#+title: deque

* monotonic deque
- it is bi-direction queue with /strictly increasing or decreasing direction/
** example
*** sliding window maximum
- find maximum of sliding subarray
  #+begin_src C++
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> q;
    for (int i = 0; i < k; i++) {
        while (!q.empty() && nums[q.back()] < nums[i]) q.pop_back();
        q.push_back(i);
    }
    vector<int> ans;
    ans.push_back(nums[q.front()]);
    int n = nums.size();
    for (int i = 1, j = k; j < n; i++, j++) {
        while (!q.empty() && q.front() < i) q.pop_front();
        while (!q.empty() && nums[q.back()] < nums[j]) q.pop_back();
        q.push_back(j);
        ans.push_back(nums[q.front()]);
    }
    return ans;
}
  #+end_src
*** continuous subarrays
- find numbers of subarrays such that /max(x_i) - min(x_i) <= 2/
#+begin_src C++
int continuousSubarrays(vector<int> &nums) {
  int n = nums.size();
  int ans = 0;
  deque<int> mxq, mnq; // decreasing queue and increasing queue to store maximum and minimum of subarray
  for (int i = 0, j = 0; j < n; j++) {
    while (!mxq.empty() && mxq.back() < nums[j]) mxq.pop_back();
    while (!mnq.empty() && mnq.back() > nums[j]) mnq.pop_back();
    mxq.push_back(nums[j]);
    mnq.push_back(nums[j]);
    while (mxq.front() - mnq.front() > 2) {
      // TODO: mxq, mnq's elements must be in nums[i..j]?
      if (mxq.front() == nums[i]) mxq.pop_front();
      if (mnq.front() == nums[i]) mnq.pop_front();
      i++;
    }
    ans += j - i + 1;
  }
  return ans;
}
#+end_src

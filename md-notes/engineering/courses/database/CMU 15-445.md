[CMU 15-445/645](https://15445.courses.cs.cmu.edu/spring2024)
# chap 1: relational model
[lec](https://15445.courses.cs.cmu.edu/spring2024/notes/01-relationalmodel.pdf)
- organized collection of inter-related data that models some aspect of real world
- database system management (DBMS)
	- software to store and analyze information in database
	- supports the definition, creation, querying, update and administration of databases
- data model and schema
	- data model
		- collection of concepts describing the data
	- schema
		- description of particular collection of data (data model)
	- relational model
		- unordered set contains the relationship of attributes represent entities
		- defines database abstration based on relations to avoid maintenance overhead (reduce cost?)
		- structure: the definition of database's relations and their contents
		- integrity: ensure database's contents satisfy constraints
		- manipulation: provide programming interface for modifying database's contents
		- data independence
			- isolate user/application from low-level data representation
![[Pasted image 20240420170332.png | 600]]
- relational model
	- primary keys
		- uniquely indentifies a single tuple
		- types:
			- indentity (sql standard)
			- sequence (postgresql/oracle)
			- increment (mysql)
	- foreign keys
		- specifies that an attribute from relation maps to a tuple in another relation
	![[Pasted image 20240420170839.png | 600]]

	- constraints
		- user-defined conditions that must hold for any instance of database
- data manipulation languages (DML)
	- procedural (relational algebra) -> find desired results
		- operations:
			- select, projection, union, intersection, difference, product (generate all combinations of tuples, neednt common values - cross join)
			- join:
				- generate tuples are combination of two tuples with common values
		- define high-level steps to compute a query
	- non-procedural (declarative - relational calculus) -> specify what data is wanted
- queries
	- relational model is independent of any query implementation
- conflict-free replicated data type (CRDT)
	- for distributing data structure that allows local updates to be made independently, and the states eventually converage
	- a family of replicated data types with a common set of properties that enable operations to always converage to a final state consistent among all replicas
	- perform replication as commutative operations (the order doesnt matter)
	- eventual consistency vs strong consistency?
		- strong consistency propagates any update to all copies of data (keep the same order). when a entity makes update, all other replicas are locked to avoid conflicts -> neednt for real-time performance -> eventual consistency (regardless of the order of update events -> resolve conflicts of concurrent updates) 
- another data models
	- document
		- collection of record documents containing a hierarchy of named field/value pairs
		- tightly coupling objects and databases
		- some databases: mongodb, ...
	- vector
		- use for nearest neighbor searching by embedded vectors (exact or approximate), maily for ML systems
# chap 2: modern sql
[lec](https://15445.courses.cs.cmu.edu/spring2024/notes/02-modernsql.pdf)
- sql is based on bags - multisets (allow duplicates) not sets (no duplicates)
- aggregate functions
	- `AVG`, `MIN`, `MAX`, `SUM`, `COUNT` -> used in `SELECT` output list
	- `COUNT`, `SUM`, `AVG` support `DISTINCT` modifier
	```sql
SELECT COUNT(DISTINCT login)
FROM student WHERE login LIKE '%@cs'
```
- `GROUP BY` projects tuples into subsets and calculate aggregates on each subset
	```sql
SELECT AVG(s.gpa), e.cid
FROM enrolled AS e JOIN student AS s
ON e.sid = s.sid
GROUP BY e.cid
```
- `HAVING` filters results based on aggregation computation, similar to `WHERE` for `GROUP BY` clause
	```sql
SELECT AVG(s.gpa) AS avg_gpa, e.cid
FROM enrolled AS e, student AS s
WHERE e.sid = s.sid
GROUP BY e.cid
HAVING AVG(s.gpa) > 3.9; -- not HAVING avg_gpa > 3.9;
```
- `LIKE` for string matching
	- '%' matches any substring (including empty string)
	- '\_' matches any character
- string operations
- date/time operations
- output direction
	- store results in another (temporary) table: `INSERT`
- output control
	- `ORDER BY` (ASC|DESC)
	- `FETCH` with offset
- window functions
	[ranking window function](https://datalemur.com/sql-tutorial/sql-rank-dense_rank-row_number-window-function)
	- perform sliding calculation across a set of tuples, like an aggregation but not grouping
	- steps:
		- partition data
		- sorts each partition
		- create a window and compute an answer for each window
		```sql
SELECT 
  RANK() / DENSE_RANK() / ROW_NUMBER() OVER ( -- Compulsory expression
    PARTITION BY partitioning_expression -- Optional expression
    ORDER BY order_expression) -- Compulsory expression
FROM table_name;
```
	- functions:
		- `ROW_NUMBER`: the number of current row -> assign unique sequential number
		- `RANK`: the order position of current row -> handle tied values by assign same rank number, and skip sequential ranks
		- `DENSE_RANK`: same as `RANK` but not skipping sequential ranks
	- grouping:
		- `OVER`: clause specifies how to grouping tuples together
		- `PARTITION BY`: specify group
		```sql
SELECT * FROM (
SELECT *, RANK() OVER (PARTITION BY cid
ORDER BY grade ASC) AS rank
FROM enrolled) AS ranking
WHERE ranking.rank = 2;
```
- nested queries
	- invoke queries inside of other queries -> difficult to optimize
	```sql
SELECT name FROM student
WHERE sid IN (
SELECT sid FROM enrolled
WHERE cid = '15-445'
);
```
- lateral join
	- `LATERAL` allows a nested query to reference attributes in other nested queries that precede it
	```sql
SELECT * FROM course AS c -- for each course
LATERAL (SELECT COUNT(*) AS cnt FROM enrolled -- compute the number of enrolled students
WHERE enrolled.cid = c.cid) AS t1,
LATERAL (SELECT AVG(gpa) AS avg FROM student AS s -- compute the average gpa of enrolled students
JOIN enrolled AS e ON s.sid = e.sid
WHERE e.cid = c.cid) AS t2;
```
- table expression
	- an alternative to windows/nested queries when writing complex queries (though as a temporary table is scoped for a single query) -> write auxiliary statements
# chap 3+4: database storage
- DBMS assumes that primary storage location is non-volatile disk (disk), DBMS' components manage the movement of data between non-volatile (disk) and volatile storage (ram)
![[Pasted image 20240503001425.png | 600]]
- random access on non-volatile storage is much slower than sequential access -> DBMS want to maximize sequential access (data is stored in contiguous blocks)
- DBMS uses **mmap** (memory-mapped file - a syscall to map files/devices into memory [blog](https://eric-lo.gitbook.io/memory-mapped-io/shared-memory)) to store the contents of file into memory address space of program
### file storage
- DBMS stores database as one or more files (collections of pages) on disk in a proprietary format
- storage manager maintains database's files: tracks data read/written to pages, available space, ...
#### database page
- is a fixed-size block of data, given a unique id
- 3 types:
	- hardware page: usually 4KB (kilobytes), is largest block of data that storage manager can guarantee failsafe writes
	- OS page: 4KB, x64 2MB/1GB?
	- database page: 512B - 32KB
- DBMSs manage pages in files in different ways
	- heap file
		- is an unordered collection of pages, need metadata to track
	- tree file
	- sequential/sorted file
	- hashing file

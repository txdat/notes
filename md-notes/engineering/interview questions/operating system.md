1. process vs thread?
- process:
	- is program execution
	- memory is isolated between processes (must be modified by 1 process at specific time)
	- processes can communicate with others by socket
	- multi-process is more than 1 process running simultaneously on computer
	- child process:
		- created by 1 process
		- inherit most of properties from its parent, create new properties like id, lock, ...
- thread:
	- segment of a process. a process can have one or more threads (with 1 main thread)
	- threads in same process can access same memory allocation
	- cpu costs less resources to switch between threads than processes - needn't to change memory space
	- multi-thread is more than 1 thread running simultaneously by 1 process
	- thread pool:
		- manage concurrent execution
2. concurrency vs parallelism vs multi-threading?
- [concurrency-parallelism](https://jenkov.com/tutorials/java-concurrency/concurrency-vs-parallelism.html)
- concurrency: tasks can start, run, and complete in overlapping time periods -> lead to race condition
	- make progress on more than 1 task at the same time. if computer has 1 cpu, cpu switches between the different tasks during execution
- parallel execution
	- cpus (more than 1 cpu) make progress on more than 1 task simultaneously. parallel execution != parallelism
- parallel concurrent execution
	- make progress tasks on cpus simultaneously (parallel), multi tasks on each cpu (concurrency)
- parallelism: multiple threads/processes working on same task using multiple CPUs
	- application splits its tasks into smaller subtasks, which can be processed parallel at the same time -> != parallel (concurrent) execution
	- have more than 1 thread and each thread must run on seperate cpus
	-> concurrency refers to how a single cpu make progress multiple tasks seemingly at the same time
	-> parallelism refers to how an application can be processed parallel by spliting a task into smaller subtasks
3. race condition?
	- multi-threading issue
	- data race
		- more than 1 thread/process that access to shared memory/resources
		- at least 1 thread/process that changes shared resources' values
	-> use 'mutual exclusion' to guarantee that only 1 thread/process modifies shared memory/resource at any time
	- race condition:
		- not control order and number of executions of threads/processes
4. locking mechanism?
	- threads have independent execution context (similar to processes), but they ==share same memory space==
	- lock variable protects critical section -> all threads competing for critical section share same lock -> only one thread acquires lock at a time, and other threads have to wait
	- concurrency - [MIT_6.005](https://web.mit.edu/6.005/www/fa15/classes/19-concurrency/)
		- means multiple computations happening at the same time
		- 2 models
			- shared memory: concurrency modules interact by reading/writing shared objects in memory
			- message passing: concurrency modules interact by sending messages to each other through communication channel
		- processes, threads, and time-slicing
			- process:
				- an instance of a running program, and ==is isolated from other processes== -> has its own private section of memory, and cannot access to other processes' memory
			- thread:
				- a locus of control inside a running program (at least 1 thread - main thread in each process)
				- ready for shared memory -> can read all other threads' memory in same a process
			- time-slicing:
				- concurrency simulation -> cpu switches between threads ==unpredictably and nondeterministically==
		- race condition:
			- the correctness of a program
			- thread safe strategies:
				- confinement: dont give other threads the abilitiy to read/write data directly
				- use imutable references and data types
				- use thread safe data types
				- synchronization: prevent threads (except one?) access shared data at the same time (implemeted in thread safe data types?)
					- use 'lock' -> 2 actions: acquire/release
					- deadlock: threads wait others forever (circular dependency)
1. virtual memory & paging?